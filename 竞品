这是一个非常精准的战略切入点。**Goose** 和 **AFFiNE** 分别代表了你构想中天平的两端：一个是极致的**执行者（Doing）**，一个是极致的**记录者（Thinking）**。

你的 **Prizm** 如果能站在中间，将“思考”与“执行”打通，就能形成巨大的差异化。

以下是详细的对比分析和差异化战略：

### 1. 深度对比：Goose vs. AFFiNE vs. Prizm (你的设想)

| 维度 | **Goose** (by Block) | **AFFiNE** (Pro/AI) | **Prizm** (你的设想) |
| --- | --- | --- | --- |
| **核心定位** | **AI 工程师/执行工** | **下一代知识库/白板** | **HAE (人机协作环境)** |
| **形态隐喻** | 命令行/终端的进化版 (Terminal++) | 笔记本/画布 (Canvas) | **IDE (集成开发环境)** |
| **知识管理 (记忆)** | **极弱**。依赖临时上下文或读取本地文件，没有结构化的“笔记”界面。 | **极强**。结构化文档 + 无边白板，擅长整理复杂的思维。 | **融合**。知识库不仅是给人看的，也是给 Agent 读取的“长期记忆”。 |
| **执行能力 (手脚)** | **极强**。可以运行 Shell、编辑代码、操作 Git。它是来“干活”的。 | **弱**。AI 仅限于在软件内部生成文字、润色、画图，无法操作 OS。 | **全权限**。通过 MCP/OpenClaw，具备操作系统级 (OS-Level) 的调度能力。 |
| **交互模式** | **命令式 (Command)**。<br>

<br>"帮我把这个 repo 克隆下来并修复 bug。" | **辅助式 (Assist)**。<br>

<br>"帮我扩写这段话，或者把这些便利贴整理成表格。" | **共生式 (Symbiosis)**。<br>

<br>"我们一起做这个项目。我写大纲，你写代码，并自动部署。" |
| **主要痛点** | 用完即走，没有“家”的感觉。不适合做长期的项目规划。 | 是一个信息孤岛。文档里的计划无法自动变成系统里的行动。 | (目前市场空白) 缺乏一个能把“规划”直接变成“行动”的统一界面。 |

---

### 2. 你的核心差异化机会 (The Differentiation Strategy)

你不能只做“更好的 Obsidian”或“更好的 Goose”，你要做的是**连接两者断层的桥梁**。

#### 差异化一：从“静态文档”变为“可执行文档” (Executable Knowledge)

* **AFFiNE 的做法：** 文档是死的文字。你写下“每天早上8点备份电脑”，这只是一行字。
* **Goose 的做法：** 你在聊天框输入“备份电脑”，它执行一次。第二天你还得说一次。
* **Prizm 的差异化：** **“文档即脚本，笔记即任务”。**
* 在 Prizm 的笔记中，用户可以用自然语言写下 SOP（标准作业程序）。
* Agent 能够**持久化地挂载**在这个文档上。
* *场景:* 你在一个“项目主页”里写下开发计划，Agent 会自动根据计划去创建文件夹、初始化 Git、安装依赖，并在文档里的 Checkbox 上自动打钩。



#### 差异化二：从“黑盒聊天”变为“透明工作台” (Glass Box Workflow)

* **Goose 的做法：** 也就是 Chat UI。你输入，它输出。中间发生了什么？它读了哪些文件？如果不看日志，你很难一目了然。
* **Prizm 的差异化：** **IDE 级的状态可视化。**
* 参考 Cursor/VS Code 的布局。
* 左侧是**知识树 (Obsidian)**，中间是**协作区 (Editor)**，右侧是 **Agent 状态面板 (OpenClaw)**。
* 当 Agent 在工作时，用户可以看到它正在修改哪个文件（高亮显示），正在读取哪条笔记（引用显示）。这种**“可观测性” (Observability)** 是专业人士最需要的。



#### 差异化三：原生 MCP 宿主 vs. 插件系统 (Native MCP Host)

* **现有产品：** 大多是通过私有插件或简单的 API 调用。
* **Prizm 的差异化：** **把 MCP (Model Context Protocol) 作为核心架构。**
* 把 Prizm 定义为桌面上最好的 **MCP Client**。
* 这意味着：用户只要安装了 Prizm，他在 Prizm 里连接的 GitHub MCP、Slack MCP、Filesystem MCP，不仅能对话，还能直接通过 UI 交互。
* 你可以做一个可视化的“技能市场”，让用户像装 VS Code 插件一样装 Agent 能力。



---

### 3. 具体的功能/场景举例 (Feature Gaps)

为了打败这两个对手，你的 MVP (最小可行性产品) 应该包含它们做不到的一个场景：

**场景：这就是 Prizm 的威力**

> **用户任务：** "我要研究一下最新的 React 框架，写一篇技术博客，并把演示 Demo 跑起来。"

1. **在 AFFiNE 里：** 用户写笔记，然后切出去打开 VS Code 写代码，再切出去打开终端跑代码，再切回来写博客。**（割裂）**
2. **在 Goose 里：** 用户让 Goose 写代码跑代码。但是“研究笔记”和“博客草稿”没有地方存，关了窗口就没了，或者散落在聊天记录里。**（健忘）**
3. **在 Prizm 里 (HAE)：**
* 用户新建一个 Page：“React 研究”。
* **Agent (LobeChat能力):** 自动搜索网络，把总结填入文档。
* **Agent (OpenClaw能力):** 用户在文档里选中一段代码块，点击“Run”。Agent 在后台（本地环境）运行代码，并把运行结果（截图或日志）**回填**到文档里。
* **结果：** 这是一个**活的**研究文档。代码可运行，笔记可沉淀，环境可复用。



### 总结

* **Goose** 是一个**工具 (Tool)**。
* **AFFiNE** 是一个**空间 (Space)**。
* **Prizm** 应该是一个**工作台 (Workbench)**。

你的护城河在于：**只有你允许用户在一个界面里，既能像写日记一样思考（Obsidian），又能像用命令行一样控制电脑（OpenClaw）。** 这种“文武双全”的体验，是目前最大的痛点。